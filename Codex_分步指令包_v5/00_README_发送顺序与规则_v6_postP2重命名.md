# Codex 分步指令包 v5（发送顺序与总规则）

你将把本包文档**按顺序逐个**发送给 Codex。每一份文档都独立包含：
- 本阶段目标（Scope）
- 允许/禁止改动
- 必须交付物
- 自验证/验收标准（你将用它判断“过关/不过关”）

## 发送规则（必须遵守）
1) **一次只发一个阶段文档**（P0→P4），并明确告诉 Codex：**本次只做本阶段，不要做后续阶段**。
2) Codex 每次提交后，你先按该阶段的“验证方法”跑通再进入下一阶段。
3) 任何阶段没通过：停止推进，要求 Codex 修本阶段直到通过。
4) 每个阶段都必须输出：改动文件列表 + 关键实现说明 + 运行命令。


## 统一实验协议（所有阶段共用，强制）
> 目的：用同一把尺子量每次改动，避免“能跑但不知道是不是更好了”。

1) **固定随机种子**
- 训练与评估均固定 `seed`（建议 42），并在启动日志打印：seed、random/numpy/torch 是否已设置。
- 若使用并行环境：第 k 个子环境用 `seed + k`。

2) **固定评估路径与回合设置**
- 评估路径集合：`line / square / s_shape`（与你论文三类一致）。
- 每阶段至少做一次 quick_eval：每条路径评估 `E=20` episode（冒烟可先 `E=5`），`max_steps` 使用 config 默认。
- 必须输出每条路径指标：  
  - `success_rate`（到终点率）  
  - `oob_rate`（越界/崩溃/非法终止率）  
  - `rmse_mean`（或你现有 RMSE 指标）  
  - `steps_mean`（到终点步数均值；失败则记为 max_steps）  
  - `v_mean`（平均速度/速度比；若能分段，额外打印直线段 vs 拐角段）

3) **固定“有效参数”打印（来自 YAML 的最终生效值）**
每次启动必须打印（至少一次）：
- `dt = environment.interpolation_period`
- `kinematic_constraints` 关键值（MAX_VEL/MAX_ACC/MAX_JERK…以及动作上下限）
- `gamma`（若训练）与有效视界：`H_steps ≈ 1/(1-gamma)`、`H_time ≈ dt/(1-gamma)`

4) **输出格式（便于你对比/粘贴）**
建议 Codex 每次提交都附上一段类似：
- `[RUN] seed=42 dt=... gamma=... H_steps=... H_time=...`
- `[EVAL] path=line success=... oob=... rmse=... steps=... v_mean=...`
- `[EVAL] path=square ...`
- `[EVAL] path=s_shape ...`

> 说明：`PPO_project_问题解析.md` 主要给你理解“为何退化”，不作为逐阶段指令。给 Codex 时以 `00 + P0..P4` 为准（解析文档最多在第一次贴一次即可）。

## 总目标（最终验收）
- 训练效果至少达到旧版单文件脚本（PPO最终版_改进.py）水准；
- 在此基础上：直线快进给、拐角可内切（至少 corridor fallback）、快速出弯、且到终点率稳定 >=95%。

## 建议你对 Codex 的每次消息模板（强烈建议复制使用）
> 你只需要把对应阶段文档粘贴给 Codex，并在开头加上下面这段：  
> 
> **模板：**  
> “本次只做【阶段名】。不要做后续阶段。请严格按文档交付物提交，并确保我能按文档里的验证方法一次跑通。提交时列出所有改动文件与运行命令。”

——下面开始按顺序发送：`01_P0_...` → `02_P1_...` → `03_P2_...` → `04_P3_...` → `05_P4_...`

---

## [更新] P2 之后的发送顺序（已重命名）

从 P2 通过后，后续阶段请按以下顺序逐关推进（每次只执行一个阶段，验收通过再进入下一关）：

1) `04_P2_5_修复PlPr偏移线生成（无交叉_左右语义一致）.md`
2) `05_P3_0_完成判据修复（open终点_闭环lap_进度单调）.md`
3) `06_P3_1_VirtualCorridor走廊奖励（带滞回_corridor_status_可开关）.md`
4) `07_P4_0_直线快进给_出弯加速_必到终点（含dt-gamma视界打印）.md`

> 注意：`P3.0` 是“完成判据修复”，是 P3/P4 的前置；未通过前禁止进入走廊奖励与提速策略阶段。
