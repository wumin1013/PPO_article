# 08_P5.0 动作量纲统一：速度比→物理量（让 P4 提速真正生效）_v1
> 前置条件：P4.0 已通过（能跑、能到终点、P4 结构已在）。  
> 本阶段目标：把 **policy 输出的速度比/角速度比** 映射为**物理速度/角速度**，使 `MAX_VEL/MAX_ANG_VEL`、`v_ratio_exec`、KCM 约束、P4 的 `speed_target/v_ratio_cap` **量纲一致**。  
> 这是后续“自由内切幅度、真实可控性边界、多预瞄平顺刹车”的**硬前置**。

---

## 目标（Scope）
1) 保持 action_space 不变：`theta_u ∈ [-1,1]`，`v_u ∈ [0,1]`（仍是“比率”）
2) step 内把比率映射到物理意图：  
   - `omega_intent = theta_u * MAX_ANG_VEL`（rad/s）  
   - `v_intent = v_u_exec * MAX_VEL`（单位与路径坐标一致，如 mm/s）
3) KCM 约束输入、`apply_action()` 执行动作、state 记录、`v_ratio_exec` 计算全部统一量纲
4) 保留 `action_policy`（比率）与 `action_exec`（物理量）两套输出用于诊断

---

## 允许改动的文件
- `src/environment/cnc_env.py`
- （可选）`src/environment/reward.py`（若 reward 使用了 v_ratio_exec 的计算方式）
- 新增：`tools/p5_unit_sanity.py`（必做）

## 禁止改动（本阶段不要碰）
- 走廊奖励形状（P3.1 的 e_target 等先不改，留到 P5.2）
- turn/kappa 的计算方法（LOS/多预瞄留到 P5.1 / P6.0）
- PPO 算法主体

---

## 任务 1：动作比率 → 物理意图（必须）
在 `env.step()` 里，保留 `action_policy`（比率）不变，但新增/替换为物理意图：

### 1.1 速度比裁剪（延续 P4 turning-feasible cap 的思路）
- `v_u_policy = clip(policy_length, 0, 1)`
- `v_u_exec = min(v_u_policy, v_ratio_cap)`  （注意：此处仍是“比率层”的 cap）

### 1.2 映射到物理量（关键）
- `omega_intent = policy_theta * MAX_ANG_VEL`
- `v_intent = v_u_exec * MAX_VEL`

> 重要：KCM 的线速度/角速度约束参数（MAX_VEL/MAX_ANG_VEL）是物理量；  
> 因此 KCM 的输入也必须是物理量。

### 1.3 KCM 输入与 max_vel_cap（必须一致）
- `max_vel_cap_phys = min(MAX_VEL, v_ratio_cap * MAX_VEL)`（本质仍是 ratio cap）
- 调用约束：
  - `apply_kinematic_constraints(..., raw_linear_vel_intent=v_intent, raw_angular_vel_intent=omega_intent, ..., max_vel=max_vel_cap_phys, ...)`
- 执行动作（给 `apply_action`）使用 KCM 输出的物理速度/角速度：
  - `safe_action = (angular_vel_phys, linear_vel_phys)`

### 1.4 state/obs 的动作字段统一（必须）
你现在 state 的前两维是 `theta_prime, length_prime`。本阶段强制：
- 这两维记录 **实际执行的物理量**：  
  - `theta_prime = angular_vel_phys`  
  - `length_prime = linear_vel_phys`
- 依旧在 `info` 里返回：
  - `action_policy`：比率形式 `[theta_u, v_u]`
  - `action_exec`：物理量 `[omega_phys, v_phys]`
  - `v_ratio_policy / v_ratio_exec`：便于对齐

理由：Observation 的 normalize 已按 `MAX_ANG_VEL/MAX_VEL` 归一化；只有物理量填进去才会得到正确的 [-1,1] 范围。

---

## 任务 2：修正 v_ratio_exec 的定义（必须）
- `v_ratio_exec = linear_vel_phys / MAX_VEL`
- `v_ratio_policy = v_u_policy`（比率）
- 自检要求：在直线段且 cap=1 时，应出现 `v_ratio_exec ≈ v_ratio_policy`（受 MAX_ACC/MAX_JERK 影响会有爬升延迟，但最终应接近）。

---

## 任务 3：新增 tools/p5_unit_sanity.py（必做）
脚本目的：不用训练也能验证“量纲一致 + P4 提速结构可工作”。

### 3.1 场景 A：直线路径 + 固定动作
- action：`theta_u=0, v_u=1`
- 跑 300 step（或 5s）
- 期望：
  - `linear_vel_phys` 最终接近 `MAX_VEL`（受加速度约束逐步爬升）
  - `v_ratio_exec` 最终接近 1
  - `action_exec[1]` 与 `v_ratio_exec*MAX_VEL` 一致

### 3.2 场景 B：急弯附近 cap 生效（只验证“裁剪链路”）
- 用 square（或任一拐角）
- 固定 `v_u=1`，观察 `v_ratio_cap` 下降时：
  - `v_ratio_exec <= v_ratio_cap` 恒成立
  - `linear_vel_phys <= MAX_VEL * v_ratio_cap` 恒成立

输出建议（必须打印）：
- `[SANITY] v_u_policy=... v_ratio_cap=... v_ratio_exec=... v_phys=...`
- `[SANITY] omega_u=... omega_phys=...`

---

## 自验证/验收标准（你将这样验证）
1) **量纲一致性（硬指标）**  
   - 运行 `tools/p5_unit_sanity.py` 场景 A：  
   - **验收：** `v_ratio_exec` 能爬升到接近 1，且 `v_phys` 达到 `O(MAX_VEL)` 量级。

2) **cap 链路生效（硬指标）**  
   - 场景 B：  
   - **验收：** 两条不等式恒成立：  
     - `v_ratio_exec <= v_ratio_cap`  
     - `v_phys <= MAX_VEL * v_ratio_cap`

3) **quick_eval 回归（必须）**  
   - 不要求更好，但要求不崩：line/square/s_shape 各 E=5 评估  
   - **验收：** 至少 line 能稳定到终点；square/s_shape 不出现“完全动不了/完全越界”的灾难性退化

---

## 交付物（提交时必须包含）
1) 改动文件列表 + 关键实现说明（尤其：ratio→phys 的映射点）  
2) `tools/p5_unit_sanity.py`  
3) `p5_unit_sanity` 的输出样例（包含场景 A/B）  
4) quick_eval 打印样例（line/square/s_shape）
