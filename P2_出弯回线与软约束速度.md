# 指令文档 P2：出弯回线 + 最小降速（让行为更像“工业级轨迹规划”）

**前置**：P1 已通过（拐角圆滑）。  
**目标**：过弯后快速回到原始轨迹中心线；同时尽量少降速、少抖动。

---

## Step 1 增加“回线奖励”：误差在下降就给正分
### 1.1 修改文件
- `PPO_project/src/environment/reward.py`

### 1.2 思路
记录上一步的横向误差 `e_prev`（可以用 RewardCalculator 内部状态保存），每步计算：
- `delta_e = |e_prev| - |e_now|`
- 在 exit phase 给：`r_recover = + w_rec * clamp(delta_e, -e_clip, +e_clip)`

exit phase 的判据（任选其一，推荐 1）：
1) 用 `corridor_status.exit_active`（如果你重新启用 corridor）
2) 用几何判据：`distance_to_next_turn` 从小变大，并且上一段 `next_angle` 较大（近似“刚出弯”）
3) 简化：`|next_angle|` 从大变小后的若干步

---

## Step 2 把速度目标变“软目标”而不是硬规则
你现在的 `p4.speed_target_reward` 本质是“策略必须追一个人为速度曲线”。建议改成：

- 不再计算 `speed_target_reward`
- 改为惩罚“过弯时过快导致的不可达转向”：  
  用曲率指标 `kappa = omega_exec / max(v_exec, v_eps)`：
  - 在 corner phase：`r_kappa = - w_kappa * (|kappa| - kappa_ref(next_angle))_+^2`
  - 其中 `kappa_ref` 只需要大致随角度增大而增大，不需要精确

这样策略会自己学到“拐角该降多少速才不出界”，而不是被硬 cap 卡死。

---

## Step 3（可选）重新启用 corridor，但只保留“边界势垒”
如果你想在拐角允许更大自由度（在允差带内走更灵活的圆弧），可以重新启用 corridor，但把它定位为“安全势垒”而不是“强引导”：

- `corridor.enabled: true`
- `center_weight: 0` 或极小
- `barrier_weight` 保留（防撞边界）
- `dir_pref_weight` 先设 0（避免把轨迹钉死在某一侧）

---

## Step 4 验收标准（P2 结束条件）
1. **出弯回线更快**：同一测试集上，出弯后达到 `|e_n| < 0.1*half_epsilon` 的平均步数比 P1 下降 ≥ 30%
2. **速度损失更小**：拐角窗口内速度均值 ≥ P1 的 90%
3. **全程稳定**：成功率 ≥ 95%，无明显振荡（`|angular_acc|` 与 `|jerk|` 无异常尖峰）

---

# P2 的产出
到 P2，你的策略会更接近“工业轨迹规划”：提前入弯、圆弧过弯、出弯回线、尽量保持速度，同时仍然是 RL 主导而非规则硬编码。
