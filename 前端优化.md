这一点的确是我考虑不周。在上一版指令中，为了追求“轻量化”，我们只在前端重建了参考路径（中心线），忽略了至关重要的**允差带（Tolerance Tube/Boundary）**。对于轨迹跟踪任务来说，没有允差带就无法直观判断智能体是否“出界”，监控体验确实大打折扣。

既然我们已经有了 `latest_trajectory.csv`（实际轨迹），现在只需要在**前端 (`app.py`)** 绘图时，利用配置文件重建出环境的物理边界即可，**无需修改后端训练代码**。

以下是 **优化指令 09：监控可视化升级（增加允差带）**。

------

# 优化指令 09：监控可视化升级 (Visualization Upgrade)

## 1. 背景与目标

问题： 目前的实时监控仅显示了“参考线”和“实际轨迹”，缺少“允差带（绿色管道）”。用户无法直观判断轨迹是否满足工程约束。

目标： 修改 app.py 的监控渲染逻辑。在绘制实时轨迹前，先通过配置文件实例化一个“哑环境 (Dummy Env)”，利用其内置的几何计算能力获取左/右边界 (Pl, Pr)，并绘制出完整的公差带管道。

## 2. 核心逻辑变更

原逻辑 (指令 08)：

读取 Config -> _build_path -> 得到中心线 -> 绘图。

新逻辑 (指令 09)：

读取 Config -> _build_env (构建完整环境) -> env.reset() (触发边界计算) -> 从 env.cache 提取左/右边界 -> 绘图。

------

## 3. 代码修改任务 (`app.py`)

请打开 `PPO_project/app.py`，找到 **`render_training_monitor`** 函数，替换原有的“实时轨迹监控”代码块。

### 步骤 A：引入环境构建逻辑

在读取到 `latest_trajectory.csv` 和 `config.yaml` 之后，不要只调用 `_build_path`，而是直接复用 `app.py` 中已有的 `_build_env` 函数来重建环境上下文。

### 步骤 B：重写绘图逻辑

使用 Plotly 的 `fill='toself'` 属性来绘制允差带。

**参考代码逻辑 (请替换原有的绘图部分):**

Python

```
    # ... (前文：读取 df, 绘制 Reward/Loss 图表) ...
    st.plotly_chart(fig, use_container_width=True)
    st.dataframe(df.tail(15), use_container_width=True)

    # === [优化版] 实时轨迹监控 (含允差带) ===
    traj_path = run_dir / "logs" / "latest_trajectory.csv"
    config_path = run_dir / "config.yaml"
    
    if traj_path.exists() and config_path.exists():
        st.divider()
        st.subheader(f"最新回合轨迹 (Episode {df['episode_idx'].iloc[-1]})")
        
        try:
            # 1. 准备数据
            # 读取实际轨迹 CSV
            traj_df = pd.read_csv(traj_path)
            
            # 2. 重建环境上下文 (为了获取 Pl/Pr 边界)
            # 加载配置
            saved_config, _ = load_config(str(config_path))
            # 创建哑环境 (CPU模式即可，仅用于几何计算)
            # 注意：_build_env 已经在 app.py 中定义过，直接调用
            dummy_env = _build_env(saved_config, torch.device("cpu"))
            dummy_env.reset() # <--- 关键！触发 reset 才能在 cache 中生成 Pl/Pr
            
            # 3. 提取几何信息
            # 使用 app.py 中已有的 _clean_boundary 辅助函数
            pl = _clean_boundary(dummy_env.cache.get("Pl", []))
            pr = _clean_boundary(dummy_env.cache.get("Pr", []))
            ref_points = dummy_env.Pm
            
            # 4. 绘图 (Layer by Layer)
            traj_fig = go.Figure()

            # Layer 1: 允差带 (Tolerance Tube)
            if pl and pr:
                # 拼接多边形坐标: 左边界正序 + 右边界倒序
                band_x = [p[0] for p in pl] + [p[0] for p in pr][::-1]
                band_y = [p[1] for p in pl] + [p[1] for p in pr][::-1]
                
                traj_fig.add_trace(go.Scatter(
                    x=band_x, y=band_y,
                    fill="toself",
                    fillcolor="rgba(44,160,44,0.15)", # 浅绿色半透明
                    line=dict(color="rgba(0,0,0,0)"), # 无边框
                    name="Tolerance Tube",
                    hoverinfo="skip"
                ))

            # Layer 2: 参考路径 (Reference)
            ref_x = [p[0] for p in ref_points]
            ref_y = [p[1] for p in ref_points]
            traj_fig.add_trace(go.Scatter(
                x=ref_x, y=ref_y,
                mode='lines',
                name='Reference',
                line=dict(dash='dash', color='blue', width=1)
            ))

            # Layer 3: 实际轨迹 (Actual)
            traj_fig.add_trace(go.Scatter(
                x=traj_df['x'], y=traj_df['y'],
                mode='lines',
                name='Actual',
                line=dict(color='#e45756', width=2.5)
            ))
            
            # 布局设置：强制等比例 (关键！)
            traj_fig.update_layout(
                height=550,
                title="Real-time Trajectory Visualization",
                xaxis_title="X (m)", yaxis_title="Y (m)",
                yaxis=dict(scaleanchor="x", scaleratio=1), # 保证圆形不被压扁
                legend=dict(orientation="h", y=1.1)
            )
            
            st.plotly_chart(traj_fig, use_container_width=True)
            
        except Exception as e:
            # 容错处理：文件可能正在写入中，或者配置加载失败
            st.warning(f"可视化渲染挂起 (数据同步中...): {e}")
```

------

## 4. 验证效果

1. **无需重启训练：** 如果你的训练正在运行，直接刷新网页（或等待 Streamlit 自动刷新）。
2. **视觉检查：**
   - 你应该能看到一条浅绿色的管道（允差带）。
   - 蓝色的虚线（参考线）位于管道中央。
   - 红色的实线（智能体）在管道内穿梭。
3. **判断标准：** 现在你可以通过肉眼观察红线是否**冲出了绿色区域**，来判断当前 Episode 是否违背了硬约束，而不仅仅是看 Reward 数值。

这一版修改充分利用了 `app.py` 现有的工具函数 (`_build_env`, `_clean_boundary`)，以最小的代码代价实现了最完整的视觉信息重建。