------

# 优化指令 09：全自动监控与交互体验重构 (Auto-Monitoring & UX Overhaul)

## 1. 背景与目标 (Context)

当前 Dashboard 存在两个主要痛点：

1. **被动且卡顿：** 用户必须手动点击刷新，且由于文件锁死（File Lock）和渲染机制问题，轨迹图经常处于“挂起”状态。
2. **控制不便：** 结束训练任务的操作隐藏在侧边栏或不直观，用户希望在选择实验的下拉框或主界面中能直接、快捷地终止进程。

**目标：** 实现 Dashboard 的 **“零操作”自动刷新**，并重构任务管理 UI，使其“所见即所控”。

------

## 2. 第一阶段：实现全自动实时监控 (Auto-Refresh Implementation)

**核心原理：** 利用 Streamlit 的重运行机制 (`rerun`) 配合非阻塞延时，替代手动按钮。

### 步骤 1.1：构建“无锁”数据读取器

操作文件： PPO_project/app.py

执行动作：

- **废弃旧读取方式：** 严禁直接使用 `pd.read_csv()` 读取正在训练中的日志文件。
- **实现 `load_data_safe`：** 创建一个带重试机制的读取函数。
  - **逻辑：** 尝试读取 -> 捕获 `PermissionError/OSError/EmptyDataError` -> 休眠 0.1秒 -> 重试 (最多 5 次)。
  - **关键参数：** 读取时必须设置 `engine='python'` 或 `on_bad_lines='skip'` 以防止正在写入的行导致解析错误。
  - **缓存策略：** 给该函数加上 `@st.cache_data(ttl=2)` 装饰器，设置 2 秒的缓存过期时间，防止过度读取硬盘。

### 步骤 1.2：植入自动刷新循环

操作文件： PPO_project/app.py

执行动作：

- **新增控件：** 在页面顶部或侧边栏添加一个开关 `st.toggle("开启实时监控 (Auto-Refresh)", value=True)`。
- **自动循环逻辑：**
  - 如果该开关开启，且当前有训练进程正在运行：
    1. 在代码末尾调用 `time.sleep(2)` (2秒刷新一次，避免卡死)。
    2. 紧接着调用 `st.rerun()` (强制重绘页面)。
  - **效果：** 用户开启开关后，页面会自动跳动刷新，无需任何点击，轨迹图也会随之动态更新。

------

## 3. 第二阶段：任务管理 UI 重构 (Process Management UX)

**核心原理：** 将“查看状态”与“控制状态”合并，让用户在看到任务的同时就能结束它。

### 步骤 2.1：重构“正在运行”区域

操作文件： PPO_project/app.py

执行动作：

- **移除侧边栏隐藏入口：** 将原本在 Sidebar 的“进行中任务”区域移动到主界面的**最显眼位置**（例如“Step 1”上方）。
- **卡片式展示：** 使用 `st.status` 或 `st.expander` 显示当前正在跑的实验。
- **动态下拉框集成：**
  - 修改“选择实验”的逻辑。如果检测到后台有该实验的 PID 在运行，在下拉框旁边或下方直接显示状态：“🟢 正在训练 (PID: 12345)”。

### 步骤 2.2：添加一键终止按钮

操作文件： PPO_project/app.py

执行动作：

- **红区控制台 (Red Zone)：** 在检测到当前选中的实验正在运行时，显式渲染一个红色的 **“⛔ 立即结束训练 (Stop Training)”** 按钮。
- **回调逻辑：**
  1. 点击按钮后，立即向对应 PID 发送 `SIGTERM` 信号。
  2. 清除 `session_state` 中的该进程记录。
  3. **立即**调用 `st.success("任务已终止")` 并执行 `st.rerun()`，让界面瞬间恢复到“未运行”状态。

------

## 4. 第三阶段：可视化防卡死优化 (Visualization Stabilization)

**核心原理：** 将 Matplotlib 彻底替换为 Plotly（交互式且不阻塞后端），或严格管理 Matplotlib 生命周期。

### 步骤 3.1：全面 Plotly 化

操作文件： PPO_project/app.py

执行动作：

- **替换图表：** 检查所有 `st.pyplot()` 的调用。如果是绘制 Reward 曲线或 Loss 曲线，全部重写为 `st.plotly_chart()`。
- **优势：** Plotly 是前端渲染，不会因为后端 Python 线程在处理文件 I/O 而导致图表画出一半卡住（"挂起"）。

### 步骤 3.2：异常兜底

操作文件： PPO_project/app.py

执行动作：

- 在绘制轨迹图（Trajectory Plot）的代码块外层包裹 `try...except`。
- **逻辑：** 如果因为数据不完整（例如 `latest_trajectory.csv` 刚写了一半）导致绘图失败，**不要报错**，而是显示一个 `st.warning("数据同步中，下一帧即将显示...")`，并让程序继续运行。这能彻底解决“挂起”问题。

------

## 5. 自验证清单 (Verification Checklist)

请在修改后按以下标准验收：

1. **自动刷新测试：** 启动训练后，开启“实时监控”开关，双手离开键盘鼠标，屏幕上的 Loss 曲线和轨迹图应每隔 2 秒自动跳动更新一次。
2. **一键结束测试：** 在主界面顶部看到当前任务状态，点击红色的“停止”按钮，任务应立即消失，且不再占用 GPU/CPU 资源。
3. **抗干扰测试：** 在训练过程中，即使 CSV 文件正在被写入，Dashboard 也不应出现报错堆栈信息，最差情况只能显示“同步中”。