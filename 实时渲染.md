# 优化指令 08：实时轨迹可视化监控系统 (Real-time Trajectory Viz)

## 1. 背景与痛点分析

**现状：** 目前的“被动监控模式”仅通过读取 `training_log.csv` 展示了标量数据（如 Reward、Loss）。这意味着用户只能通过奖励值的上升来*推测*智能体学会了走直线还是走弯道，但无法直观地看到智能体当前的实际走位。

**目标：** 打通一条**低延迟、非阻塞**的数据管道，实现：

1. **后端：** 训练脚本在每完成一个回合（Episode）后，自动将该回合的完整 `(x, y)` 坐标序列转储到磁盘。
2. **前端：** 监控面板能实时感知最新的轨迹文件，并结合实验配置，绘制出“参考路径（标准答案）”与“实际路径（当前表现）”的动态对比图。

------

## 2. 系统架构设计

为了保证系统稳定性，我们将采用**“快照覆盖 (Snapshot Overwrite)”** 策略，而不是追加写入。

### 数据流图

Plaintext

```
[训练进程 main.py] 
    │
    ├─> (Step 1...N) 内存中缓存当前回合轨迹点 [(x1,y1), (x2,y2)...]
    │
    └─> (Episode End) 触发转储 -> 覆盖写入 logs/latest_trajectory.csv
                                        │
[前端进程 app.py] <─────────────────────┘
    │
    ├─> 定时刷新 (Rerun)
    ├─> 读取 config.yaml (获取参考路径参数) -> 重建理论参考线 (Blue Dash)
    ├─> 读取 latest_trajectory.csv (获取实际轨迹) -> 绘制实际轨迹 (Red Solid)
    └─> 渲染 Plotly 图表
```

------

## 3. 详细实施步骤

### 任务 A：后端数据管道构建 (`main.py`)

**核心逻辑：内存缓存 + 瞬间落盘**

请按照以下逻辑修改 `train` 函数的内部循环：

1. **初始化轨迹缓存容器：**
   - 在每个回合开始（`env.reset()`）之后，立即在内存中初始化一个空列表（例如 `current_episode_trace`），专门用于暂存本回合的坐标点。
2. **高频采样：**
   - 在训练的主循环 (`while not done`) 中，每次执行完 `env.step()` 后，立即获取环境当前的物理坐标 `env.current_position`。
   - 将该坐标追加到上述列表。
   - *注：不要在这里写文件，否则会严重拖慢训练速度。*
3. **回合末触发式写入（关键步骤）：**
   - 当回合结束 (`done=True`) 时，检查当前回合数是否满足写入条件（建议与日志打印频率 `log_interval` 保持一致，避免频繁 IO）。
   - **构建文件路径：** 目标文件应固定命名为 `latest_trajectory.csv`，存放在实验的 `logs/` 目录下。
   - **执行写入操作：**
     - 使用 **覆盖模式 ('w')** 打开文件。
     - 先写入表头：`x,y`。
     - 将内存列表中的所有点一次性写入。
   - **异常处理：** 包裹在 `try...except` 块中，防止因文件被占用导致的训练崩溃（如果写入失败，直接跳过即可，反正下一回合还会写）。

------

### 任务 B：前端可视化渲染引擎 (`app.py`)

**核心逻辑：动态重建 + 图层叠加**

请在 `render_training_monitor` 监控模块中增加以下逻辑：

1. **定位数据源：**
   - 根据用户当前选择的实验和时间戳目录，锁定两个关键文件：
     1. `config.yaml`（用于生成参考路径）。
     2. `logs/latest_trajectory.csv`（用于读取实际路径）。
2. **参考路径重建 (Reference Reconstruction)：**
   - **逻辑：** 前端无法直接从 CSV 知道这一轮是跑“S形”还是“蝴蝶形”。必须先读取同目录下的 `config.yaml`。
   - **操作：** 解析 YAML 中的 `path` 字段，复用 `src.utils.path_generator` 中的函数，在内存中重新生成一遍标准的参考路径点集 `Pm`。
   - *这一步保证了无论你跑什么轨迹，背景里的虚线永远是正确的标准答案。*
3. **实际轨迹加载 (Actual Path Loading)：**
   - 尝试读取 `latest_trajectory.csv`。
   - **防御性编程：** 由于后端正在写入时文件可能被锁定或为空，必须使用 `try...except` 捕获读取错误。如果读取失败，在界面上显示“等待数据同步...”而不是报错。
4. **双层绘图 (Dual-Layer Plotting)：**
   - 使用 Plotly 创建对象。
   - **图层 1 (底层)：** 使用重建的参考路径点，绘制**蓝色虚线**。命名为 "Reference"。
   - **图层 2 (顶层)：** 使用读取的 CSV 坐标点，绘制**红色实线**。命名为 "Actual (Ep X)"。
   - **布局优化：** 强制设置 X 轴和 Y 轴的比例为 `scaleanchor="x", scaleratio=1`。这是必须的，否则圆形的轨迹会被压扁成椭圆，误导视觉判断。

------

## 4. 验收自检清单 (Verification Checklist)

完成上述修改后，请按顺序执行测试：

1. **文件生成测试：**
   - 启动一个新训练。
   - 观察实验文件夹下的 `logs/` 目录。
   - **预期：** 应该看到 `latest_trajectory.csv` 文件，且其修改时间会随着训练进度不断更新（每隔 `log_interval` 更新一次）。
2. **内容完整性测试：**
   - 用文本编辑器打开该 CSV。
   - **预期：** 第一行是 `x,y`，下面是密密麻麻的数字，行数应大致等于 `max_steps`（或回合结束时的步数）。
3. **实时渲染测试：**
   - 打开 Dashboard 监控页面。
   - **预期：** 在 Reward 曲线下方出现了一个新的二维平面图。
   - **动态效果：** 刚开始时，红线可能乱跑（智能体还在探索）；几分钟后，红线应该开始逐渐向蓝色的虚线靠拢、重合。

------

**执行建议：** 这是一个纯粹的“锦上添花”功能，**切记不要让文件写入逻辑阻塞了训练主线程**。使用“覆盖写”而不是“追加写”是保持系统轻量化的关键